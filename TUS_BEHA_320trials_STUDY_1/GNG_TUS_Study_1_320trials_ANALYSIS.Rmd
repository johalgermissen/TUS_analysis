---
title: "GNG_TUS_Study_1_320trials_ANALYSIS"
author: "nomi"
date: "2023-10-31"
output: html_document
---

#READ FILE
```{r setup, include=FALSE}
library(readr)
tus <- read_csv("GNG_TUS_S1.csv")
View(tus)
```

#Load libraries
```{r}
library(lmerTest)
#library(lMest)
library(dplyr)
library(BayesFactor)
library(tidyverse)
library(BANOVA)
library (rstan)
library(afex)
library(rstanarm)
library(stringr)
library(report)
library(jtools) #for explanation of lmer
library(emmeans)#2 prefictor, one should be continuous (the "var")
library(effects)
library(lme4)
library(bbmle)
library(MASS)
library(MuMIn)
library(AICcmodavg)#https://www.scribbr.com/statistics/akaike-information-criterion/#:~:text=Once%20you've%20created%20several,be%20the%20better%2Dfit%20model.
#help to interpret results from AICmodavg
```

#Analysis

  ##Accuracy

    ##NB RUN A BASIC ANOVA !!!!!!!!!!!
```{r}
oneway.test(correct ~ condition,
  data = tus,
  var.equal = TRUE) # assuming equal variances

model <- aov(correct ~ condition * req_action * OutValence, data=tus)
summary(model)

summary(aov(correct ~ condition * req_action * OutValence + Error(ID/(condition * req_action * OutValence)), data=tus))
summary(aov(correct ~ condition * req_action *  OutValence + Error(ID), data=tus)) # separately testing effect of IVs but their interaction too- not sure if correct??????
```

#comparing glmer models - Logistic regression
     ####???Should check for multicollinearity by calculating a Variance Inflation Factor (VIF) for each independent variable maybe?

```{r}
### Elsa Test on stepAIC
modelTEST <- glm(correct ~ OutValence + req_action + condition, data  = tus) 
summary(modelTEST)
newmodel <- stepAIC(modelTEST, scope=list(upper= ~OutValence * req_action * condition, lower= ~1))

#Equivalent of stepAIC

      #WAY_1
# List of fixed effects
fixed_effects <- c("OutValence", "req_action", "condition", "trial_number")

# Generate all possible combinations of two-way interactions
interaction_terms_2way <- combn(fixed_effects, 2, simplify = FALSE) %>%
  lapply(function(x) paste(x, collapse = "*"))

# Generate all possible combinations of three-way interactions
interaction_terms_3way <- combn(fixed_effects, 3, simplify = FALSE) %>%
  lapply(function(x) paste(x, collapse = "*"))

# Combine two-way and three-way interaction terms
interaction_terms <- c(interaction_terms_2way, interaction_terms_3way)

# Check if there are valid combinations
if (length(interaction_terms) == 0) {
  cat("No valid combinations of interactions found.")
} else {
  # List to store models and AIC values
  model_list <- list()
  
  # Loop through each combination of interactions and fit models
  for (i in seq_along(interaction_terms)) {
    # Create formula string with interactions and random intercept
    formula_str <- as.formula(paste("correct ~", interaction_terms[[i]], "+ (1|ID)"))
    
    # Fit the model
    tryCatch({
      temp_model <- glmer(formula_str, data = tus, family = "binomial",
                          glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))
      
      # Calculate AIC and store the model
      temp_AIC <- AIC(temp_model)
      model_list[[interaction_terms[[i]]]] <- list(model = temp_model, AIC = temp_AIC)
    }, error = function(e) {
      cat("Error occurred with this formula:", deparse(formula_str), "\n")
    })
  }
  
  # Order models by AIC value
  ordered_models <- model_list[order(sapply(model_list, function(x) x$AIC))]
  
  # Print the ordered models
  print(ordered_models)
}


        #WAY_2


# Step 1: Fit a series of GLM models

        #all main effects are significant 
model1 <- glmer(correct ~ OutValence + req_action + condition +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
        #all main effects are significant
model2 <- glmer(correct ~ OutValence + req_action + condition + trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
       #all main effects and interaction is significant. val*req_action = Cue
model3 <- glmer(correct ~ OutValence * req_action + condition + trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model4 <- glmer(correct ~ OutValence * req_action * condition +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
summary(model4)#this is probably the one!

model5 <- glmer(correct ~ OutValence * req_action * condition * trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model6 <- glmer(correct ~ Cue + condition + trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model7 <- glmer(correct ~ Cue + condition + OutValence + trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model8 <- glmer(correct ~ Cue * condition + trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model9 <- glmer(correct ~ Cue * condition * trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
#not 9
model10 <- glmer(correct ~ Cue * condition * OutValence* req_action* trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model11 <- glmer(correct ~  OutValence * req_action *condition * trial_number + RT + (1|ID) ,
                   data = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
#not11
model12 <-glmer(correct ~ OutValence + req_action + condition + RT +trial_number +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model13 <-glmer(correct ~ OutValence + req_action + condition + RT +(1|ID) , 
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model14 <- glmer(correct ~ OutValence + req_action + condition + trial_number + (OutValence * req_action * condition * trial_number) + (1|ID) ,        
                 data  = tus, family="binomial", glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
#overfit i think 14, but also OutValenceWin:conditionc.ai:trial_number                  -0.0050235  0.0013815  -3.636 0.000277 ***
model15 <- glmer(correct ~ req_action + OutValence + trial_number + condition +(1|ID) + ( req_action + OutValence + trial_number + condition|ID), 
                 data  = tus, family="binomial",  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
#no 15
model16 <- glmer(correct ~ req_action * OutValence + trial_number + condition +(1|ID) + ( req_action * OutValence + trial_number + condition|ID), 
                 data  = tus, family="binomial",  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
 #takes ages and crashes
model17 <- glmer(correct ~ req_action * OutValence * trial_number * condition +(1|ID) + ( req_action * OutValence * trial_number * condition|ID), 
                 data  = tus, family="binomial",  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model18 <- glmer(correct ~ req_action + OutValence + trial_number + condition +RT +(1|ID) + ( req_action * OutValence * trial_number * condition +RT|ID), 
                 data  = tus, family="binomial",  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE

model19 <- glmer(correct ~ req_action * OutValence * trial_number * condition *RT +(1|ID) + ( req_action * OutValence * trial_number * condition *RT|ID), 
                 data  = tus, family="binomial",  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE


#model 20 not working atm


# Identify non-numeric columns
non_numeric_cols <- c("req_action", "OutValence", "trial_number", "condition", "RT")

# Convert non-numeric values to NA
tus[, non_numeric_cols] <- lapply(tus[, non_numeric_cols], function(x) {
  as.numeric(as.character(x))
})

# Replace missing values with column means
tus[, non_numeric_cols] <- lapply(tus[, non_numeric_cols], function(x) {
  ifelse(is.na(x), mean(x, na.rm = TRUE), x)
})

# Scale numeric columns
scaled_tus <- tus
scaled_tus[, non_numeric_cols] <- scale(tus[, non_numeric_cols])

# Check the class of ID column
class(scaled_tus$ID)

# Convert ID to factor if it's not already a factor
if (!is.factor(scaled_tus$ID)) {
  scaled_tus$ID <- as.factor(scaled_tus$ID)
}

# Fit the model again
model20 <- glmer(correct ~ req_action * OutValence * trial_number * condition * RT + (1|ID),
                 data = scaled_tus, family = "binomial",
                 glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))




# Step 2: Create a data frame with model names and AIC values
models_data <- data.frame(
  Model = c("model1", "model2", "model3", "model4", "model5", "model6", "model7", "model8", "model9", "model10", "model11", "model12",  "model13"))#, "model14")), "model15", "model16", "model17", "model18", "model19"),
  AIC = c(AIC(model1), AIC(model2), AIC(model3), AIC(model4), AIC(model5), AIC(model6), AIC(model7), AIC(model8), AIC(model9), AIC(model10), AIC(model11), AIC(model12), AIC(model13))#, AIC(model14), AIC(model15), AIC(model16), AIC(model17), AIC(model18), AIC(model19)))
                          

models_data$AIC <- as.numeric(models_data$AIC)
# Step 3: Order the data frame based on AIC values
models_data <- models_data[order(models_data$AIC), ]


# Step 4:Output the ordered models and AIC values
cat("Ordered AIC values:\n")
print(models_data)


      #OR
# Step 4: Compare models using aictab
# Create the AIC table
aictab_result <- aictab(cand.set = list(model1, model2, model3, model4, model5, model6, model7, model8, model9, model10, model11, model12, model13))#, model14, model15, model16, model17, model18, model19),
  modnames = c("model1", "model2", "model3", "model4", "model5", "model6", "model7", "model8", "model9", "model10", "model11", "model12", "model13")#, "model14", "model15", "model16", "model17", "model18", "model19"))
# Print the AIC table
print(aictab_result)
```

#Summary models above
```{r}
# Assuming you have a list of 10 models named model1, model2, ..., model10
model_list <- list(model1, model2, model3, model4, model5, model6, model7, model8, model9, model10, model11, model12, model13, model14)

# Use lapply to get summaries for all models
model_summaries <- lapply(model_list, summary)

# Now you can access each summary using model_summaries[[1]], model_summaries[[2]], and so on
model_summaries[[4]]
```


 
```{r}

# do not hot to combine the allmeans or alleffects to check the beta basic level main effects.
```

#Plotting the effects? Help - not working OK
```{r}
#Not sure how to interpret the model (whichever I pick) or how to plot:
acc <- allEffects(model_acc, xlevels=list(req_action=seq(0, 24, 6)),
                   fixed.predictors=list(given.values=c(OutValenceWin =0.5)));eff.cowles

as.data.frame(acc[[]])

# the following are equivalent:
eff.ne <- effect("OutValence*req_action", model_acc)
Eff.ne <- Effect(c("OutValence", "req_action"), model_acc)
all.equal(eff.ne$fit, Eff.ne$fit)

# Assuming you have extracted the estimated effects into a data frame
# For example, using as.data.frame(eff.cowles[[2]])-->
# Create a ggplot object - not working yet
acc<-as.data.frame(acc)
ggplot(data =acc, aes(x = req_action, y = fit)) +
  geom_point() +  # Add points to the plot
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +  # Add error bars
  labs(x = "req_action", y = "Effect") +  # Label the axes
  ggtitle("Estimated Effects of req_action")  # Add a title

#or  #not working either - i do not know
plot(acc, 'OutValence', axes=list(grid=TRUE,
y=list(lab="condition"),
x=list(rotate=90)),
lines=list(lty=0))
```


#Reporting

```{r}
summ(model_acc, exp = T)# set "exp = T" to show esponentiated estimates; if you need standardised estimaets, set "scale = T"
summ(model_acc, scale = T)
report(model_acc)
report(model_acc) %>% summary()
report_table(model_acc)
report_performance(model_acc)
report_parameters(model_acc)
```
 
 
#visualize how spread accuracy is - higher variability for the STIMs
```{r}
tus_correct_sub <- na.omit(tus_correct_sub)#omit NAs

ggplot(tus_correct_sub, aes(x = correct , y = req_action, color=req_action))+
               geom_jitter(stat = "identity")+
    facet_grid(~condition)
geom_smooth(method= "lm", se = TRUE)
```


#run anovaBF (not the correct analysis as the DV is categorical - just trying)
```{r}
#as.factor
tus$ID <- as.factor(tus$ID)
tus$req_action <- as.factor(tus$req_action)
tus$condition <- as.factor(tus$condition)
tus$trial_number <- as.factor(tus$trial_number)
tus$OutValence <- as.factor(tus$OutValence)
tus$Cue <- as.factor(tus$Cue)

#drop NAs
df <- na.omit(tus)
df$ID <- as.factor(df$ID)
df$correct <- as.integer(df$correct)
df$req_action <- as.factor(df$req_action)
df$condition <- as.factor(df$condition)
df$trial_number <- as.factor(df$trial_number)
df$OutValence <- as.factor(df$OutValence)
df$Cue <- as.factor(df$Cue)


#anovaBF IV = req_action
 accu <-anovaBF(correct ~ req_action*condition  + ID, data = df, whichRandom = "ID",
   progress=FALSE)
accu[4]/accu[3]

#anovaBF IV = Cue - interaction between the Cue and the condition
accu_cue <-anovaBF(correct ~ Cue*condition  + ID, data = df, whichRandom = "ID",
   progress=FALSE)
accu_cue[4]/accu_cue[3]
lm(RT ~ condition +req_action +OutValence, data=tus)



#banova!!!!!!!! - not working atm
# Making sure JAGS is installed
# It can be downloaded here http://mcmc-jags.sourceforge.net (the size is only 2.3 MB)

BANOVA::BANOVA.run (correct ~ req_action, ~condition*req_action, data=df, model_name = 'Binomial', id = 'ID',
                        as.integer(16), num_trials = as.integer(20), iter = 100, thin = 5, chains = 2)
```

#RTs

```{r}
model_rt <- lmer(RT ~ req_action  + OutValence +session+ req_action*condition*trial_number +(1|ID), # + trial_number (excluded cause it gives me the outcome of all trials, it does not group them)
                 data  = tus, REML = FALSE) #REML = FALSE
summary (model_rt) 
    #print(model_rt, correlation=FALSE)
report_table(model_rt)



#run anovaBF IV = req_action and condition
 rt <-anovaBF(RT ~ req_action*condition  + ID, data = df, whichRandom = "ID",
   progress=FALSE)
accu[4]/accu[3]
summary(rt)

 


#Cue impact
model_rt_cue <- lmer(RT ~ Cue*condition +(1|ID) , 
                 data  = tus,REML = FALSE) #REML = FALSE
summary (model_rt_cue) 

#simple anova
anova(model_rt)

#anovaBF IV = Cue - interaction between the Cue and the condition
rt_cue <-anovaBF(RT ~ Cue*condition  + ID, data = df, whichRandom = "ID",
   progress=FALSE)
rt_cue[4]/rt_cue[3]
summary(rt_cue)
```


          
          
  # ANALYSIS FOR SALIENT ONLY (EXCLUDE NEUTRAL OUTCOME)
  
```{r}
#select salient only (win, lose) and keep variables ID through block and all columns between them
tus_salient <- subset(tus, salient=!"neutral",
select=ID:salient);  

salient_df <-tus_salient %>% drop_na();  View(salient_df) # WRONG IT DRPOPS ACC AS WELL

```  

        
## Accuracy
```{r}
model_acc_sal <- glmer(correct ~ condition + req_action + trial_number + OutValence*condition + req_action*condition +(1|ID) , 
                 data  = salient_df, family="binomial", 
                 glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALS
summary(model_acc_sal)

#Cue impact
sal_cue_accu <- glmer(correct ~ Cue*condition*trial_number +(1|ID) , 
                 data  = salient_df, family="binomial", 
                 glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))) #REML = FALSE
summary (sal_cue_accu) 
```

## RTs
```{r}
model_rt_sal <- lmer(RT ~ req_action  + trial_number + OutValence*condition + req_action*condition+(1|ID), 
                 data  = salient_df, REML = FALSE) #REML = FALSE
summary (model_rt_sal) 
report_table(model_rt_sal)
#Cue impact
sal_cue_rt <- lmer(RT ~ Cue*condition +(1|ID), 
                 data  = salient_df, REML = FALSE) #REML = FALSE
summary (sal_cue_rt) 
```


 ##Analysis with Bayesian binomial/logistic anova for the categorical DV - "correct"
      # with rstarm + bridging

```{r}

library(htmltools)
options(mc.cores = 4)


cor.m1.stan <- rstanarm::stan_glmer(correct ~ condition * OutValence * req_action * Cue + (1|ID),  weights=trial_number,
                 data  = tus, family="binomial", chains=4, iter=2e4, 
                diagnostic_file = "__df1.csv") #deleted the "weights = ..."

cor.m1.0.stan <- rstanarm::stan_glmer(correct ~ (condition + OutValence + req_action) * Cue + (1|ID), weights=trial_number,
               data  = tus, family="binomial", chains=4, iter=2e4, 
                diagnostic_file = "__df0.csv") #notsure if this the base model. #deleted the "weights = ..."

bridge_1 <-bridgesampling::bridge_sampler(cor.m1.stan)
bridge_0 <- bridgesampling::bridge_sampler(cor.m1.0.stan)
# BW: this gives evidence (or not) for the interaction
bayes_factor(bridge_1, bridge_0, log = FALSE)



##model with no interaction 
acc.m2.stan <- rstanarm::stan_glmer(is_slip ~ condition * Cue + (1|ID), 
               data  = elm_test.byblock, family="binomial", chains=4, iter=2e4, 
                diagnostic_file = "__df2.csv")

acc.m3.0.stan <- rstanarm::stan_glmer(is_slip ~ condition + Cue + (1|ID), 
                weights=exposure, data  = elm_test.byblock, family="binomial", chains=4, iter=2e4, 
                diagnostic_file = "__df2.0.csv")

bridge_3 <-bridgesampling::bridge_sampler(acc.m2.stan)
bridge_3.0 <- bridgesampling::bridge_sampler(acc.m3.0.stan)


# evidence
bayes_factor(bridge_3, bridge_3.0, log = FALSE)

```

