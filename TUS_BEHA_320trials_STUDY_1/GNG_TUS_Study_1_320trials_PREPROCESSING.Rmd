---
title: "GNG_TUS_Study_1_320trials_preprocessing"
author: "nomi"
date: "2023-10-31"
output: html_document
---

 

# LOAD LIBRARIES
```{r}
#library(Rccp)
#library(rlang)
library(tibbletime)
library(purrr)
library(stringr)
library(report)
#library(ggplot)
library(ggplot2)
library(dplyr)
#library(lmer)
library(tidyverse)
library(patchwork)
library(ggpubr)
library(jtools) #for explanation of lmer
library(yarr)
library (yarrr)
library(afex)
#install.packages("devtools")
#devtools::install_github("mikabr/ggpirate")
#library(ggpirate)
#p_load ( rms, htmltools, bridgesampling, rstanarm, magrittr, scales, RColorBrewer, 
# parsnip, zoo, wesanderson, yarr, BiocManager, afex, GGally, lmerTest, aod, splines)
```

#APA theme
```{r}
theme_APA <- theme_bw()+
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          axis.line = element_line(size = 1),                                        
          text = element_text(
              size = 20,
              face="bold"), 
          axis.text = element_text(
              size = 20,
              face="plain",
              colour="black"),
          legend.title = element_blank(),
          legend.position = 'top',
          legend.direction = "horizontal",
          legend.text = element_text(
              face="plain",
              colour="black",
              size=20),
          strip.text.x = element_text(
              size = 20,
              face = "bold"),
          panel.background = element_rect(
              fill='white',
              colour='white'),
          strip.background = element_rect(
              fill='white',
              colour='white'),
          axis.title.x = element_text(
              margin = margin(t = 10)),
          plot.margin = grid::unit(c(5, 5, 5, 5), "mm"),
          plot.caption = element_text(size=15)
          )
```


    #PREPROCESSING

## insert .txt files
```{r}
a.sham<- tibble(filename = list.files("1.SHAM", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
c.ai<- tibble(filename = list.files("3.AI", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
b.dacc<- tibble(filename = list.files("2.dACC", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
```

## add condition column
```{r}
a.sham <- a.sham %>%
      mutate (condition="a.sham")
c.ai <- c.ai %>%
      mutate (condition="c.ai")
b.dacc <- b.dacc %>%
      mutate (condition="b.dacc")
```

## Set variable names
```{r}
a.sham <- a.sham %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
b.dacc <- b.dacc %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
c.ai <- c.ai %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
```


## combine datasets
```{r}
tus <-bind_rows(a.sham, c.ai, b.dacc)

```

## add session column
```{r}
# Extract numbers at the end of each level and create a new column
tus<-tus %>%
  mutate(session = as.factor(str_extract(ID,"(?<=\\D)\\d+(?=_log.txt)")))
#View(tus)
```


## Change name of ID rows to match the subj_ID (i.e.  "pilot data/DBGE0324_log.txt" --> "DBGE0324")
```{r}
tus <- tus %>%
      mutate_at("ID", str_replace, "1.SHAM/", "")# & "log.txt", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "3.AI/", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "2.dACC/", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_1", "")
#tus <- tus %>%
   #   mutate_at("ID", str_replace, "_SHAM__1", "_sham")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_1", "")
#tus <- tus %>%
    #  mutate_at("ID", str_replace, "_ACC_2", "_dACC")
#tus <- tus %>%
#      mutate_at("ID", str_replace, "_ACC_1", "_dACC")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_1", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_log.txt", "")
#tus <- tus %>%
  #    mutate_at("ID", str_replace, "SINB_0180", "SINB0180")
#copied
#tus <- tus %>%
   #   mutate_at("ID", str_replace, "_Copy", "")
```

## Add response col (press - no_press)
```{r}
tus$response <- with(tus, ifelse(RT>0, "press", "no_press"))
tus$GoResponse <- with(tus, ifelse(RT>0, 1, 0)) 
```

## Add Cue column (if stim_ID=NGW then NGW, etc. for  NGL, GW, GAL)
```{r}
tus$Cue <- ifelse(tus$stim_ID == tus$NGL, 'NGL',
                ifelse(tus$stim_ID == tus$NGW, 'NGW', 
                ifelse(tus$stim_ID == tus$GW, 'GW', 
              ifelse(tus$stim_ID == tus$GAL, 'GAL', NA))))
    ```

## Add GNG col (Go-noGO)
```{r}
tus$req_action <- ifelse(tus$stim_ID == tus$NGL, 'noGo',
                ifelse(tus$stim_ID == tus$NGW, 'noGo', 'Go'))   
#NB's way: 
#pilot$ReqAction <- ifelse(pilot$Cue == 'NGL', 'NoGo',
            #       ifelse(pilot$Cue == 'NGW', 'NoGo',
             #      ifelse(pilot$Cue == 'GW', 'Go',
              #      felse(pilot$Cue == 'GAL', 'Go', NA))))

```
 
## Add correct column (0-1)  
```{r}
tus <- tus %>%
  mutate(correct = ifelse(req_action == "noGo", ifelse(response == "no_press", 1, 0), 
         
                    ifelse(req_action == "Go", ifelse(response == "press", 1, 0), 1)))
```
        
## Trial column 
```{r}
#1,2,3...100...320
tus <- tus %>%
  group_by(ID, condition) %>%
  mutate(trial_number = row_number())
```


## block colums 1, 2, 3, 4   =====sos with the trials that have 400 instead of 320
```{r}
tus$block <- ifelse(tus$trial_number == 1:80, '1',
                ifelse(tus$trial_number == 81:160, '2', 
                ifelse(tus$trial_number == 161:240, '3', 
              ifelse(tus$trial_number == 241:320, '4', NA))))
# counts trials of the same condition within each block
count_trials <- rollify(function(x) sum(last(x) == x), window=80)#turns a function 
#into a rolling version of itself for use inside of a call to dplyr::mutate() ,
# however it works equally as well when called from purrr::map()
```

## trial_count column
```{r}
tus <- tus %>%
  group_by(ID, block, condition) %>%
  mutate(TrialCount = count_trials(Cue)) %>%
  group_by(ID, block,condition, Cue) %>%
  mutate(TrialCount = ifelse(is.na(TrialCount), row_number(ID), TrialCount))
```


## Add win_lose column (win - lose) 
```{r}
tus$feedback <- recode_factor(tus$outcomefeed, "-1" = "lose", 
                                "1" = "win", "0"= "neutral")

```
      
## Add Win/Avoid condition column (if stim_ID=NGW then NGW, etc. for  NGL, GW, GAL)
```{r}
tus$OutValence <- ifelse(tus$Cue == 'NGL', 'Avoid',
                   ifelse(tus$Cue == 'NGW', 'Win',
                   ifelse(tus$Cue == 'GW', 'Win',
                   ifelse(tus$Cue == 'GAL', 'Avoid', NA))))
```

## Add salient feedback column only
```{r}
tus <- tus %>%
  mutate(salient = ifelse(feedback == "win","win",
                      ifelse(feedback == "lose", "lose", NA)))
```
    
        #'followup_beha' showing response after feedback + 1 in trial_number
#after loss and after winning feedback behaviour. Add a column based on feedback 
showing what response/behaviour they have chosen, go or noGo. Maybe something like
for feedback [i], mutate column [followup_beha] showing response after feedback +1 in trial_number,
grouping by ID and condition.
```{r}

# Convert feedback column to a factor (if it's not already a factor)
tus$feedback <- as.factor(tus$feedback)

# Mutate column 'followup_beha' showing response after feedback + 1 in trial_number
tus <- tus %>%
  group_by(ID, condition, Cue, req_action) %>%
  mutate(followup_beha = lead(response, order_by = trial_number, default = NA))

# Count the number of occurrences for each level of the Cue column, to check is balanced
 cue_counts <- table(tus$Cue);print(cue_counts); View(tus)
```


              # whether they are correct after a correct feedback
              Find the follow up behaviour after receiving the correct feedback ( or whether they were correct after receiving the correct feedback 80% and not the 20%)

correct feedback
  when NGL and response:no_press and  feedback neutral, then 1 else 0 =>  add to column -> correct_feedback 
  when GW and response: press and and feedback win, then 1, else 0 =>  add to column -> correct_feedback
  when GAL and response press and and feedback neutral, then 1, else 0=>  add tocolumn ->correct_feedback
  when NGW and response no_press and feedback  win, then 1, else 0 =>  add to column ->correct_feedback
  how to find the follow-up behaviour. Create a column called correct_proba_feed
  
  
following correctation (whether they were correct after receiving the correct feedback 80% and not the 20%)

previous you have done something similar for general follow up behaviour after feedback like this:

!!!!!!!!!!!!!!!!!! NEUTRAL is ALSO correct when NGL and GAL and they get 0 and feedback was 0
  
  model <- lme(followingcorrectation ~ correctfeedback + (1|sub), dataframe = xxx)
  
```{r}
library(dplyr)

# Step 1: Calculate correct_feedback based on specified conditions (check in which instanses feedback was correct 80%) - all good!
tus <- tus %>%
  mutate(correct_feedback = case_when(
    is.na(Cue) ~ NA_real_,  # If Cue is NA, assign NA to correct_feedback
    Cue == "NGL" & response == "no_press" & feedback == "neutral" ~ 1,
    Cue == "GW" & response == "press" & feedback == "win" ~ 1,
    Cue == "GAL" & response == "press" & feedback == "neutral" ~ 1,
    Cue == "NGW"  & response == "no_press"& feedback == "win" ~ 1,
    Cue == "NGL" & response == "press" & feedback == "lose" ~ 1,
    Cue == "GW" & response == "no_press" & feedback == "neutral" ~ 1,
    Cue == "GAL" & response == "no_press" & feedback == "lose" ~ 1,
    Cue == "NGW"  & response == "press"& feedback == "neutral" ~ 1,
    TRUE ~ 0
  ))

        #check percentages and if 80% 20%
        table(tus$feedback)
        table(tus$correct_feedback)

                    
total_count <- 26240
count_0s <- 4904
count_1s <- 21156
count_lose <- 3910
count_win <- 8503
count_nutral <- 13647

      # Calculate proportions 
          count_0s <- count_0s / total_count; print(count_0s)
                count_1s <- count_1s / total_count; print (count_1s)

        # Step 2: Calculate followup_response after correct feedback   -not yet
      library(dplyr)

# Add a column indicating follow-up response after correct feedback
tus <- tus %>%
  mutate(followup_response = case_when(
    correct_feedback == 1 ~ lead(response, order_by = trial_number, default = NA),
    TRUE ~ NA_character_  # For rows where correct_feedback is not 1, set followup_response as NA
  ))

# View the updated dataset
View(tus)





```

plotting of after feedback behaviour
```{r}
library(ggplot2)

              ################general
#A#
   #Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Create a grouped bar plot showing the distribution of follow-up behaviors after each type of feedback
ggplot(feedback_data, aes(x = feedback, fill = followup_beha)) +
  geom_bar(position = "dodge", color = "black", stat = "count") +
  labs(title = "Response Distribution after Different Types of Feedback",
       x = "Feedback", y = "Count") +
  scale_fill_manual(values = c("press" = "lightgreen", "no_press" = "pink")) +
  theme_minimal()



#B# - NOT MUCH
 #count general

# Count occurrences of press and no_press per condition
press_counts <- feedback_data %>%
  group_by(feedback, followup_beha) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = followup_beha, values_from = count, values_fill = 0)

# Calculate the mean of press and no_press responses per condition
mean_press <- press_counts %>%
  summarise(mean_press = mean(press),
            mean_no_press = mean(no_press))

# Plotting
#Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "correct"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Define custom colors
custom_colors <- c("Press" = "#66c2a5", "No Press" = "#fc8d62")

# Plot counts of "press" and "no_press" per condition
ggplot(press_counts, aes(x = feedback)) +
  geom_bar(aes(y = press, fill = "Press"), stat = "identity", position = "dodge", color = "black", show.legend = TRUE) +
  geom_bar(aes(y = no_press, fill = "No Press"), stat = "identity", position = "dodge", color = "black", show.legend = TRUE) +
  #facet_wrap(~ condition, scales = "free") +
  labs(title = "Accuracy of 'press' and 'no_press' of follow_up response after feedback",
       x = "Feedback", y = "Accuracy") +
  scale_fill_manual(values = custom_colors,
                    guide = guide_legend(title = "Follow-Up Behavior", 
                                         labels = c("Press", "No Press"))) +
  theme_minimal() +
  theme(legend.position = "right")










         ####for accuracy
# A# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
accuracy_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "correct", "condition"))

# Exclude NA values
accuracy_data <- na.omit(accuracy_data)

# Create a grouped bar plot showing the mean of correct responses after each type of feedback for accuracy
# Check the range of the 'correct' variable
summary(accuracy_data$correct)

# Assuming the minimum value is 0.25 or greater, set the y-axis limits using coord_cartesian
ggplot(accuracy_data, aes(x = feedback, fill = followup_beha, y = correct)) +
  geom_bar(position = "dodge", color = "black", stat = "summary", fun = "mean") +
  labs(title = "Mean Correct Responses after Different Types of Feedback (Accuracy)",
       x = "Feedback", y = "Mean Correct Response") +
  scale_fill_manual(values = c("press" = "lightgreen", "no_press" = "pink")) +
  theme_minimal() +
  #facet_grid(~condition)+
  coord_cartesian(ylim = c(0.2, 1))







 
           ####for RT
#A# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
rt_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "RT"))

# Exclude NA values
rt_data <- na.omit(rt_data)

# Create a grouped bar plot showing the mean of reaction times after each type of feedback for RT
ggplot(rt_data, aes(x = feedback, fill = followup_beha, y = RT)) +
  geom_bar(position = "dodge", color = "black", stat = "summary", fun = "mean") +
  labs(title = "Mean Reaction Time after Different Types of Feedback (RT)",
       x = "Feedback", y = "Mean Reaction Time") +
  scale_fill_manual(values = c("press" = "lightgreen", "no_press" = "pink")) +
  theme_minimal()+
  coord_cartesian(ylim = c(0, 600))




#per condition - DOES IT MAKE

  #count second one is better for count
# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "Cue"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Create a grouped bar plot showing the distribution of responses after each type of feedback, separated by condition
ggplot(feedback_data, aes(x = feedback, fill = followup_beha)) +
  geom_bar(position = "dodge", color = "black", stat = "count") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Response Distribution after Different Types of Feedback by Condition",
       x = "Feedback", y = "Count") +
  scale_fill_manual(values = c("press" = "#66c2a5", "no_press" = "#fc8d62")) +
  theme_minimal()+
  coord_cartesian(ylim = c(0, 2500))



   #count per condition - better

# Count occurrences of press and no_press per condition
press_counts <- feedback_data %>%
  group_by(feedback, condition, followup_beha) %>%
  summarise(count = n()) %>%
  pivot_wider(names_from = followup_beha, values_from = count, values_fill = 0)

# Calculate the mean of press and no_press responses per condition
mean_press <- press_counts %>%
  group_by(condition) %>%
  summarise(mean_press = mean(press),
            mean_no_press = mean(no_press))

# Plotting (after win and neutral AI and DACC were pressing more)!!!!!!!!!!
# Define custom colors
custom_colors <- c("Press" = "#66c2a5", "No Press" = "#fc8d62")

# Plot counts of "press" and "no_press" per condition
ggplot(press_counts, aes(x = feedback)) +
  geom_bar(aes(y = press, fill = "Press"), stat = "identity", position = "dodge", color = "black", show.legend = TRUE) +
  geom_bar(aes(y = no_press, fill = "No Press"), stat = "identity", position = "dodge", color = "black", show.legend = TRUE) +
  facet_wrap(~ condition, scales = "free") +
  labs(title = "Counts of 'press' and 'no_press' per Condition",
       x = "Feedback", y = "Count") +
  scale_fill_manual(values = custom_colors,
                    guide = guide_legend(title = "Follow-Up Behavior", 
                                         labels = c("Press", "No Press"))) +
  theme_minimal() +
  theme(legend.position = "right")



#mean per condition for the followup_beha - not stacked [KEEP]

# Calculate counts of 'press' and 'no_press' for each combination of feedback, followup_beha, and condition

feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "Cue"))
# Exclude NA values
feedback_data <- na.omit(feedback_data)

count_data <- feedback_data %>%
  group_by(feedback, followup_beha, condition) %>%
  summarise(count = n()) %>%
  ungroup()



# Calculate the total counts (sum of 'press' and 'no_press') for each combination of feedback and condition
total_counts <- count_data %>%
  group_by(feedback, condition) %>%
  summarise(total_count = sum(count))

# Merge total counts with count data
count_data <- count_data %>%
  left_join(total_counts, by = c("feedback", "condition"))

# Calculate the mean proportion of 'press' and 'no_press' for each combination of feedback and condition
mean_proportion <- count_data %>%
  mutate(mean_proportion = count / total_count)

# Separate mean proportions for 'press' and 'no_press'
mean_press <- mean_proportion %>% filter(followup_beha == "press")
mean_no_press <- mean_proportion %>% filter(followup_beha == "no_press")

# Create the grouped bar plot showing the mean proportion of 'press' and 'no_press' per feedback and condition
ggplot(mean_proportion, aes(x = feedback, y = mean_proportion, fill = followup_beha)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_wrap(~ condition, scales = "free", drop = FALSE) +  # Retain all levels of 'condition'
  labs(title = "Mean Proportion of 'press' and 'no_press' per Feedback by Condition",
       x = "Feedback", y = "Mean Proportion") +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62"), name = "Follow-Up Behavior",
                     labels = c("Press", "No Press")) +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 0.6), breaks = seq(0, 1, 0.1))  # Set y-axis limit and breaks





   #add [per Cue] as a facet variable too [keep]
# Filter data for GW and GAL
gw_gal_data <- mean_proportion %>%
  filter(Cue %in% c("GW", "NGW"))

# Generate plot for GW and GAL
ggplot(gw_gal_data, aes(x = feedback, y = mean_proportion, fill = followup_beha)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Mean Proportion of 'press' and 'no_press' per Feedback by Condition for GW and NGW",
       x = "Feedback", y = "Mean Proportion") +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62"), name = "Follow-Up Behavior",
                     labels = c("Press", "No Press")) +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 0.6), breaks = seq(0, 1, 0.1))  # Set y-axis limit and breaks

# Filter data for NGW and NGL
ngw_ngl_data <- mean_proportion %>%
  filter(Cue %in% c("GAL", "NGL"))

# Generate plot for NGW and NGL
ggplot(ngw_ngl_data, aes(x = feedback, y = mean_proportion, fill = followup_beha)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Mean Proportion of 'press' and 'no_press' per Feedback by Condition for GAL and NGL",
       x = "Feedback", y = "Mean Proportion") +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62"), name = "Follow-Up Behavior",
                     labels = c("Press", "No Press")) +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 0.6), breaks = seq(0, 1, 0.1))  # Set y-axis limit and breaks




#mean per condition for the followup_beha - stacked [KEEP]

# Calculate the mean of "press" and "no_press" per condition
mean_press <- feedback_data %>%
  group_by(feedback, condition) %>%
  summarise(mean_press = mean(followup_beha == "press"),
            mean_no_press = mean(followup_beha == "no_press"))

# Define custom colors
custom_colors <- c("Press" = "#66c2a5", "No Press" = "#fc8d62")

# Plot the mean of "press" and "no_press" per condition
ggplot(mean_press, aes(x = feedback)) +
  geom_bar(aes(y = mean_press, fill = "Press"), stat = "identity", position = "dodge", color = "black") +
  geom_bar(aes(y = mean_no_press, fill = "No Press"), stat = "identity", position = "dodge", color = "black") +
  facet_wrap(~ condition, scales = "free") +
  labs(title = "Mean of 'press' and 'no_press' of follow_up beha per Condition",
       x = "Feedback", y = "Mean") +
  scale_fill_manual(values = custom_colors,
                     guide = guide_legend(title = "Follow-Up Behavior", 
                                          override.aes = list(fill = custom_colors))) +
  theme_minimal() +
  coord_cartesian(ylim = c(0.2, 0.6))+
  theme(legend.position = "right")


 

                  

                #mean condition accuracy
# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "correct"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Calculate the mean of 'correct' per condition
accuracy_data <- aggregate(correct ~ feedback + followup_beha + condition, data = feedback_data, FUN = mean)

# Create a grouped bar plot showing the mean of correct responses after each type of feedback, separated by condition
ggplot(accuracy_data, aes(x = feedback, y = correct, fill = followup_beha)) +
  geom_bar(position = "dodge", color = "black", stat = "identity") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Mean Correct Responses after Different Types of Feedback by Condition",
       x = "Feedback", y = "Mean Correct Response") +
  scale_fill_manual(values = c("press" = "#66c2a5", "no_press" = "#fc8d62")) +
  theme_minimal() +
  coord_cartesian(ylim = c(0.3, 1)) # Set the y-axis limits





#B# fill it up - NOOOOO it seems almost the same, look #A#****************
# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "correct"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Calculate the mean accuracy of 'correct' per condition
accuracy_data <- aggregate(correct ~ feedback + followup_beha + condition, data = feedback_data, FUN = mean)

# Calculate the mean accuracy of "press" and "no_press" per condition
mean_accuracy <- accuracy_data %>%
  group_by(feedback, condition) %>%
  summarise(mean_press = mean(correct[followup_beha == "press"]),
            mean_no_press = mean(correct[followup_beha == "no_press"]))

# Define custom colors
custom_colors <- c("Press" = "#66c2a5", "No Press" = "#fc8d62")

# Plot the mean accuracy of "press" and "no_press" per condition
ggplot(mean_accuracy, aes(x = feedback)) +
  geom_bar(aes(y = mean_press, fill = "Press"), stat = "identity", position = "dodge", color = "black") +
  geom_bar(aes(y = mean_no_press, fill = "No Press"), stat = "identity", position = "dodge", color = "black") +
  facet_wrap(~ condition, scales = "free") +
  labs(title = "Mean Accuracy of 'press' and 'no_press' of follow-up behavior per Condition",
       x = "Feedback", y = "Mean Accuracy") +
  scale_fill_manual(values = custom_colors,
                     guide = guide_legend(title = "Follow-Up Behavior", 
                                          override.aes = list(fill = custom_colors))) +
  theme_minimal() +
  coord_cartesian(ylim = c(0, 1)) +
  theme(legend.position = "right")







        #mean condition rt [KEEP]
# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "RT"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Calculate the mean of 'RT' per condition
rt_data <- aggregate(RT ~ feedback + followup_beha + condition, data = feedback_data, FUN = mean)

# Create a grouped bar plot showing the mean of RT after each type of feedback, separated by condition
ggplot(rt_data, aes(x = feedback, y = RT, fill = followup_beha)) +
  geom_bar(position = "dodge", color = "black", stat = "identity") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Mean Reaction Time after Different Types of Feedback by Condition",
       x = "Feedback", y = "Mean Reaction Time") +
  scale_fill_manual(values = c("press" = "#66c2a5", "no_press" = "#fc8d62")) +
  theme_minimal() +
  coord_cartesian(ylim = c(100, max(rt_data$RT, na.rm = TRUE) * 1.1)) # Set the y-axis limits




#B# fill it up -*********check it is correct [KEEP]

library(tidyr)

# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_beha", "condition", "RT"))

# Exclude NA values
feedback_data <- na.omit(feedback_data)

# Create a data frame with all combinations of feedback, followup_beha, and condition
all_combinations <- expand.grid(feedback = levels(feedback_data$feedback),
                                followup_beha = unique(feedback_data$followup_beha),
                                condition = unique(feedback_data$condition))

# Left join the all_combinations data frame with the existing data
feedback_data <- left_join(all_combinations, feedback_data, by = c("feedback", "followup_beha", "condition"))

# Replace NA values in the RT column with 0
feedback_data$RT[is.na(feedback_data$RT)] <- 0

# Check the first few rows of the completed dataset
head(feedback_data)

# Calculate the mean RT for each combination of feedback, followup_beha, and condition
mean_rt <- feedback_data %>%
  group_by(feedback, followup_beha, condition) %>%
  summarise(mean_RT = mean(RT))

# Define custom colors
custom_colors <- c("press" = "#66c2a5", "no_press" = "#fc8d62")

# Plot the stacked bar plot
ggplot(mean_rt, aes(x = feedback, y = mean_RT, fill = followup_beha)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ condition, scales = "free") +
  labs(title = "Mean RT of 'press' and 'no_press' per Condition",
       x = "Feedback", y = "Mean RT") +
  scale_fill_manual(values = custom_colors,
                     guide = guide_legend(title = "Follow-Up Behavior")) +
    coord_cartesian(ylim = c(100,750)) +
  theme_minimal()


```
        
   
   
     #####plots for followup_response following correct feedback (80%)   
     plotting of after feedback behaviour
```{r}
# Filter data for rows where feedback is "win", "lose", or "neutral" and select relevant columns
feedback_data_r <- subset(tus, feedback %in% c("win", "lose", "neutral"), select = c("feedback", "followup_response", "condition", "Cue"))

# Exclude NA values
feedback_data_r <- na.omit(feedback_data_r)


#mean per condition for the followup_beha - not stacked [KEEP]

# Calculate counts of 'press' and 'no_press' for each combination of feedback, followup_beha, and condition
count_data_r <- feedback_data_r %>%
  group_by(feedback, followup_response, condition) %>%
  summarise(count = n()) %>%
  ungroup()

# Calculate the total counts (sum of 'press' and 'no_press') for each combination of feedback and condition
total_counts_r <- count_data_r %>%
  group_by(feedback, condition) %>%
  summarise(total_count = sum(count))

# Merge total counts with count data
count_data_r <- count_data_r %>%
  left_join(total_counts, by = c("feedback", "condition"))

# Calculate the mean proportion of 'press' and 'no_press' for each combination of feedback and condition
mean_proportion_r <- count_data_r %>%
  mutate(mean_proportion_r = count / total_count)

# Separate mean proportions for 'press' and 'no_press'
mean_press <- mean_proportion_r %>% filter(followup_response == "press")
mean_no_press <- mean_proportion_r %>% filter(followup_response == "no_press")

# Create the grouped bar plot showing the mean proportion of 'press' and 'no_press' per feedback and condition
ggplot(mean_proportion_r, aes(x = feedback, y = mean_proportion_r, fill = followup_response)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_wrap(~ condition, scales = "free") +  # Facet by condition
  labs(title = "Mean Proportion of 'press' and 'no_press' per correct Feedback by Condition",
       x = "Feedback", y = "Mean Proportion") +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62"), name = "Follow-Up Response",
                     labels = c("Press", "No Press")) +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 0.6), breaks = seq(0, 1, 0.1))  # Set y-axis limit and breaks






             #[per Cue]



# Calculate counts of 'press' and 'no_press' for each combination of feedback, followup_response, condition, and Cue
count_data_r <- feedback_data_r %>%
  group_by(feedback, followup_response, condition, Cue) %>%
  summarise(count = n()) %>%
  ungroup()

# Calculate the total counts (sum of 'press' and 'no_press') for each combination of feedback, condition, and Cue
total_counts_r <- count_data_r %>%
  group_by(feedback, condition, Cue) %>%
  summarise(total_count = sum(count))

# Merge total counts with count data
count_data_r <- count_data_r %>%
  left_join(total_counts_r, by = c("feedback", "condition", "Cue"))

# Calculate the mean proportion of 'press' and 'no_press' for each combination of feedback, condition, and Cue
mean_proportion_r <- count_data_r %>%
  mutate(mean_proportion_r = count / total_count)

# Separate mean proportions for 'press' and 'no_press'
mean_press <- mean_proportion_r %>% filter(followup_response == "press")
mean_no_press <- mean_proportion_r %>% filter(followup_response == "no_press")

# Create the grouped bar plot showing the mean proportion of 'press' and 'no_press' per feedback, condition, and Cue
ggplot(subset(mean_proportion_r, Cue %in% c("GW")), aes(x = feedback, y = mean_proportion_r, fill = followup_response)) +
  geom_bar(position = "dodge", stat = "identity") +
  facet_grid(Cue ~ condition, scales = "free") +  # Facet by Cue and condition
  labs(title = "Mean Proportion of 'press' and 'no_press' per correct Feedback by Condition and Cue",
       x = "Feedback", y = "Mean Proportion") +
  scale_fill_manual(values = c("#66c2a5", "#fc8d62"), name = "Follow-Up Response",
                     labels = c("Press", "No Press")) +
  theme_minimal() +
  scale_y_continuous(limits = c(0, 0.6), breaks = seq(0, 1, 0.1))  # Set y-axis limit and breaks

```
        
   
     
     
```{r}

```
     
        
 ##write.csv
```{r}
write.csv(tus, "GNG_TUS_S1.csv")
```

